name: Test ScanCode Output

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout repo
        uses: actions/checkout@v4

      - name: üì¶ Install ScanCode Toolkit
        run: |
          set -eux  # fail fast (-e), print commands (-x), treat unset vars as error (-u)
          git clone https://github.com/nexB/scancode-toolkit.git
          cd scancode-toolkit
          ./configure 
               
    #  - name: üîç Verify dummy file presence
    #    run: |
    #     echo "Listing files under src/lodash:"
    #     ls -R src/lodash
    #     echo "Showing dummy-gpl-file.js content:"
    #     cat src/lodash/dummy-gpl-file.js

      - name: üöÄ Run ScanCode
        run: |
          set -eux
          ./scancode-toolkit/scancode -clpeui \
            --json-pp scan-output.json \
            src/lodash

      - name: üìÑ Show last 20 lines of scan-output.json
        run: |
         set -eux
         ls -l scan-output.json
         tail -n 20 scan-output.json

#      - name: üìú Show detected licenses
#        run: |
#          echo "Detected licenses:"
#          jq -r '.. | .license_expression? // empty' scan-output.json | sort -u

      - name: üìú Show detected license expressions
        run: |
          jq -r '
            .files[]
            | (.detected_license_expression_spdx // .detected_license_expression // .license_expression)
            | select(. != null)
          ' scan-output.json | sort -u


      - name: üö® Check for risky copyleft (GPL/AGPL) ‚Äî fail only if sole
        run: |
          set -euo pipefail

          # Files with a sole risky license (FAIL)
          SOLE=$(
            jq -r '
              .files[]
              | select(.type=="file")
              | {path:.path, expr:(.detected_license_expression_spdx // .detected_license_expression // .license_expression)}
              | select(.expr != null and (.expr | type == "string"))
              | select((.expr | test("(?i)\\b(OR|AND)\\b") | not))        # sole license only
              | . as $o
              | (.expr | ascii_downcase) as $e
              | select($e | test("^(gpl-(1\\.0|2\\.0|3\\.0)(\\+|-only)?|agpl-(1\\.0|3\\.0)(\\+|-only)?)$"))
              | "\(.path)\t\(.expr)"
            ' scan-output.json
          )

          # Files where GPL/AGPL appear in a multi-license expression (WARN only)
          MULTI=$(
            jq -r '
              .files[]
              | select(.type=="file")
              | {path:.path, expr:(.detected_license_expression_spdx // .detected_license_expression // .license_expression)}
              | select(.expr != null and (.expr | type == "string"))
              | select(.expr | test("(?i)\\b(OR|AND)\\b"))                # multi-licensed
              | select(.expr | test("(?i)(^|\\W)(gpl|agpl)-"))            # contains GPL/AGPL anywhere
              | "\(.path)\t\(.expr)"
            ' scan-output.json
          )

          if [ -n "$MULTI" ]; then
            echo "‚ö†Ô∏è  Risky licenses present in multi-licensed files (warning only):"
            echo "$MULTI" | awk -F '\t' '{printf "  - %s  [%s]\n",$1,$2}'
          fi

          if [ -n "$SOLE" ]; then
            echo "üö´ Sole risky copyleft licenses detected in these files:"
            echo "$SOLE" | awk -F '\t' '{printf "  - %s  [%s]\n",$1,$2}'
            exit 1
          fi

          echo "‚úÖ No sole risky copyleft licenses detected."


     # - name: üîç Inspect first file object
     #   run: |
     #    jq '.files[0]' scan-output.json

      - name: üìú Show licenses grouped by files
        run: |
          BLUE='\033[1;34m'
          GREEN='\033[1;32m'
          RESET='\033[0m'

          echo -e "${BLUE}üìä Licenses and associated files:${RESET}"
          jq '
            .files[]
            | select(.detected_license_expression != null and .detected_license_expression != "")
            | {license: .detected_license_expression, file: .path}
          ' scan-output.json \
          | jq -s -r '
              group_by(.license)[] |
              "License: " + .[0].license + "\n" +
              (map(.file) | unique | sort | map("  - " + .) | join("\n")) +
              "\n"
            ' \
          | while IFS= read -r line; do
              if [[ "$line" == License:* ]]; then
                echo -e "License: ${GREEN}${line#License: }${RESET}"
              else
                echo "$line"
              fi
            done






    

          
